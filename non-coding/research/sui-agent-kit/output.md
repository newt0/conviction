# Sui Agent Kit (Alpha) – Deep Dive and Developer Guide

&#x20;_AI Agents are poised to be “supercharged” by Sui’s performance and tooling. The alpha Sui Agent Kit (SAK) is a new framework to build autonomous on-chain agents on Sui, combining blockchain automation with AI integration._

## 1. Overview and Design Philosophy

**What is SAK and why does it exist?** The Sui Agent Kit alpha is an open-source toolkit for creating autonomous “agents” that can interact with the Sui blockchain on behalf of users or applications. Its core purpose is to enable any agent – potentially powered by AI models – to autonomously perform on-chain tasks (e.g. token trades, staking, DeFi operations) without direct human intervention. In other words, SAK lets developers build bots or AI-driven programs that **analyze data, interact with Move smart contracts, and execute transactions in real time**. The rationale behind SAK is to simplify and accelerate _on-chain automation_: instead of requiring users to manually trigger every blockchain action, agents can handle routine or complex tasks autonomously, abstracting away blockchain complexity for end-users. Sui’s leadership envisions a future with “a billion agents” on-chain managing assets and processes long before a billion humans actively use crypto – agents can continuously manage portfolios or workflows just like a financial advisor might, but entirely in software.

**Design philosophy:** SAK’s design leverages Sui’s strengths – high throughput, low latency, and object-centric data – to support these autonomous agents. It is built to bridge AI and blockchain, reflecting the belief that _blockchain-powered AI agents_ will be a cornerstone of Web3 in coming years. Unlike generalized bot frameworks, SAK is _developer-first and model-agnostic_: it provides ready-made building blocks for on-chain operations (transfers, swaps, contract calls, etc.) while letting developers plug in any AI model or custom logic for decision-making. The goal is to **empower developers to create “smart” agents easily**, without reinventing wheels like wallet management, scheduling, or Move call integration. This philosophy mirrors Coinbase’s AgentKit and similar efforts which emphasize broad LLM support and on-chain SDK integration. SAK is part of Sui’s broader vision to be the _backbone for AI-driven agents_: by providing fast execution and rich on-chain features (like storage and identity), Sui aims to eliminate friction for autonomous agent applications.

**Comparison with Gelato and Autonolas:** Gelato Network is a well-known automation protocol on Ethereum and other EVM chains that provides a decentralized network of bots (executors) to trigger smart contract functions on schedule or when conditions are met. Gelato essentially offers “Web3 cloud” services – developers register tasks, and Gelato’s bots execute them, often enabling things like time-based trades, limit orders, or auto-rebalancing without the dev running their own infrastructure. SAK, in contrast, is currently a _toolkit rather than a service_: it gives you the pieces to build and run your own agent logic in the Sui environment. In alpha, there isn’t (yet) a decentralized executor network like Gelato’s; instead, a developer might run their agent code on a server or use a community launchpad to keep it online. The emphasis is on tight integration with Sui’s unique capabilities (Move transactions, object storage, etc.) and potentially AI algorithms, rather than providing a cross-chain automation marketplace.

Autonolas (now **Olas**) is another framework that focuses on autonomous agent services, but it emphasizes multi-agent systems running off-chain with on-chain coordination and shared ownership. Autonolas’s design introduces an “agent registry,” co-owned agents (DAOs controlling agents), and heavy security modules so multiple parties can trust an agent service. SAK’s scope in alpha is narrower – typically a single-agent pattern (though it could spawn sub-agents) acting for a user or developer with that agent’s own key. While Autonolas stresses decentralization and robust multi-agent governance, SAK (alpha) prioritizes _ease of development and direct on-chain action_. In other words, **SAK is a lightweight, Sui-optimized agent framework**: it trades the complex multi-owner, off-chain infrastructure of Autonolas for simplicity and Sui-specific optimizations (like directly calling Move contracts, or storing state on Sui’s storage layer). Over time, SAK and the Sui ecosystem may incorporate more decentralization (e.g. open agent networks or on-chain agent registries), but the alpha release is about giving individual developers the power to build an agent quickly that leverages Sui’s speed and safety.

Finally, SAK’s design is deeply influenced by the notion that _AI + blockchain_ together unlock new possibilities. The kit explicitly targets AI integration (e.g. via OpenAI or other ML models) – something Gelato doesn’t cover, and Autonolas only addresses abstractly. By being model-agnostic and LangChain-compatible, SAK lets you plug in an LLM to analyze data or make decisions, then seamlessly execute on-chain actions based on those decisions. This design decision acknowledges trends in Web3: agents might need to interpret natural language instructions or complex data with AI, then act as smart contract clients. **In summary,** the Sui Agent Kit’s philosophy is to _supercharge on-chain agents with Sui’s technical advantages (speed, rich data, Move safety) and AI interoperability_, making autonomous crypto apps far more accessible and powerful than before.

## 2. Core Components of SAK (Alpha)

**Agent definition and configuration:** In the current alpha, an agent is primarily defined by code (TypeScript/JavaScript in existing implementations) and environment settings, rather than a single JSON manifest. There is not yet a standard `agent.json` file in use – instead, developers configure the agent via code and env variables. For example, when setting up SAK locally you provide credentials like a Sui private key, RPC endpoint, and (optionally) an AI API key in an `.env` file. These values are loaded to instantiate the `SuiAgentKit` object in code, which acts as the agent’s interface to the network. In the future, we may see higher-level agent definition files (similar to Autonolas’s agent metadata or a `.well-known/agent.json` concept) to declaratively specify triggers and actions, but in the alpha release the “definition” resides in your program (scripts or config within the codebase).

**Architecture:** SAK’s architecture can be thought of in three cooperating modules: **triggers (conditions/scheduler)**, **the agent logic**, and **execution (blockchain interface)**.

- _Scheduler/Trigger Module:_ This component is responsible for deciding **when** the agent should act. In the alpha SAK, triggers are relatively basic – typically time-based loops or simple event checks coded by the developer. For instance, Nimbus’s implementation provides an “Autonomous Mode” where the agent will **execute actions every N seconds** (by default, every 10 seconds in their demo). This acts as a rudimentary scheduler, waking the agent at fixed intervals. The developer can configure the interval (“configurable intervals” are supported) or even run a one-off trigger. Conditional triggers (based on on-chain events or state) are not yet a plug-and-play feature, but they can be achieved by coding logic in the loop – e.g. each cycle the agent can query Sui state or off-chain APIs and decide if conditions warrant action. In essence, the alpha’s trigger module is **developer-defined**: you either run the agent in a continuous loop (interval polling) or call it in response to some external event (like a webhook or manual prompt). Future iterations might introduce a more declarative scheduler (for example, a cron-like syntax or an event subscription mechanism), but currently **timed loops and coded checks** serve as the triggers.

- _Agent Logic (Decision/Task Module):_ This is the core “brain” of the agent – what to do when triggered. It can be as simple as “check price and trade if above X” or as complex as an AI-powered multi-step strategy. In SAK, the agent logic often leverages AI integration through LangChain tools or custom scripts. The kit provides a framework for plugging in AI models: you can supply an OpenAI API key (or other model endpoints), and SAK includes **LangChain integration** that wraps on-chain actions as tools the AI can invoke. For example, the kit might expose a _“TransferAsset”_ tool or _“QueryBalance”_ tool that an LLM agent can call when reasoning about what steps to take. The developer can also write custom Tools (as shown in Nimbus’s guide for adding new tools) – essentially extending the agent’s capabilities by writing a function and registering it so the agent (or the AI controlling it) can use it. In non-AI scenarios, the agent logic could just be hard-coded: e.g. _“if my portfolio allocation drifts >5%, then call rebalance”_. But a key idea in SAK is **AI-driven decisions** – the agent logic can have an LLM observe data and decide which Sui actions to perform. In alpha, multiple “modes” are offered: **Interactive (Chat) Mode** for direct user queries, and **Autonomous Mode** for self-driven operation. In Chat mode, the agent waits for user input (like a question: “What’s my balance? Execute a swap if price > Y.”) and then uses its tools to respond. In Autonomous mode, the agent logic runs continuously, deciding and acting on its own every cycle.

- _Execution Module:_ This part of the architecture handles the actual _blockchain interactions_ – signing transactions, calling Move contracts, and submitting to the Sui network. SAK abstracts away the low-level details by providing convenient SDK calls for common operations. Under the hood, the execution module uses Sui’s RPC or client SDK to perform actions, and it uses the agent’s configured private key or wallet to sign transactions. For example, when the agent needs to transfer tokens or invoke a Move function, SAK will form a transaction and use the provided `SUI_PRIVATE_KEY` to **sign and execute** it via the RPC endpoint. This makes on-chain calls feel like simple function calls in your agent code. The kit includes an **abstraction layer for Move contract calls** – essentially a library of pre-built actions and an interface to construct new ones. In alpha, supported actions span a range of Sui protocol operations (more on this in the _Key Features_ section): e.g. checking balances, transferring SUI or other assets, staking/unstaking, swapping tokens on a DEX, etc., all exposed as easy-to-call methods. When one of these actions is invoked by the agent logic, the execution module handles constructing the proper Move call or transaction payload and dispatching it to the network. The execution layer is also responsible for handling **errors and retries** – for instance, if a transaction fails (due to a stale object reference or network issue), the agent can catch that and perhaps try again or log the error. SAK alpha encourages robust error handling (Nimbus’s features mention “error handling and recovery” in autonomous mode), which likely is implemented in this execution part. In summary, the execution module is what bridges the agent’s intentions to real on-chain effects, managing the cryptographic signing and submission so developers don’t have to script those from scratch.

**Deployment models and runtime environments (alpha):** In its alpha stage, SAK is flexible about where the agent runs. There are a few typical deployment scenarios:

- **Local/CLI Deployment:** A developer can run the agent on their local machine (or a server they control) as a Node.js process. This is exactly what the setup guides cover – you clone the repo or install the package, set up your `.env` with keys, and run `pnpm start` to launch the agent in either chat or autonomous mode. This approach is straightforward and good for testing or running a personal agent. However, keeping it running 24/7 requires your machine or server to stay online.
- **Cloud Functions / Serverless:** Thanks to integrations like Vercel AI, developers can deploy the agent backend to cloud platforms. The Pelagos Sui Agent Kit explicitly notes integration with **Vercel AI for seamless deployment**. In practice, one could host the agent as a web service that continuously runs or responds to triggers (e.g., an agent that wakes via a scheduled job or remains in a loop on a serverless function with appropriate settings). This model offloads the uptime burden to a cloud provider. For instance, a developer might deploy the agent as a persistent service on AWS or as a scheduled Cloud Function that executes periodically.
- **Agent Launchpads:** An emerging option is to use community platforms (agent launchpads) where you can upload or configure your agent and the platform runs it for you. The Sui community already has **SuiAI.fun** – an AI agent launchpad on Sui – which aims to let creators deploy AI agents on-chain in seconds (the Sui Foundation even promoted it). These launchpads typically provide a UI to configure an agent’s strategy or logic (sometimes without coding), then handle hosting the agent and possibly even tokenizing it. In alpha, these platforms (e.g. SuiAI.fun, RaidenX for trading bots, etc.) are experimental, but they illustrate a deployment model where the developer doesn’t run the agent at all – the platform does, in exchange for fees or a share in the agent’s “token.” For example, RaidenX touts itself as a trading bot platform for Sui, focusing on meme coins and agent tokens.
- **On-Chain Deployment:** A question often arises – can the agent logic itself run on-chain (as a smart contract)? In SAK’s current form, not exactly. The heavy logic (especially AI parts) runs off-chain in a traditional compute environment, because on-chain Move contracts can’t perform arbitrary long-running tasks or fetch external data. However, SAK does use on-chain components: your agent might deploy certain Move contracts (for state storage or to leverage Sui’s programmable transactions in new ways). One example is the **OpenGraph project** from the Sui Agent Typhoon hackathon, which deployed an _on-chain AI inference system_ using Move contracts (TensorflowSui SDK) and Walrus for storage. That suggests future agent architectures may split work between on-chain contracts (for verifiable computation or state coordination) and off-chain processes (for AI inference or complex decision-making). In alpha, though, the typical runtime is off-chain (Node.js or similar), coordinated by the developer.

In summary, the alpha SAK doesn’t prescribe a single deployment environment – you can run agents locally, in the cloud, or via emerging agent hosting services. The key is that the agent process needs a reliable connection to a Sui fullnode (via RPC) and a secure way to hold the private key for signing. As we move beyond alpha, we might see more **decentralized agent runtime** options (perhaps even validator-run agent executors or an on-chain agent scheduler), but at this stage developers have flexibility to choose a runtime that suits their needs and reliability requirements.

## 3. Key Features of Sui Agent Kit (Alpha)

Despite being an early version, SAK alpha packs several powerful features tailored to Sui’s ecosystem:

- **Scheduled & Conditional Task Execution:** SAK enables agents to perform **scheduled actions** or react to conditions, automating tasks that would otherwise require manual triggering. In the alpha, scheduling is primarily achieved via the autonomous loop mechanism – an agent can be set to run at fixed intervals (e.g. every 10 seconds by default) and execute predefined actions repeatedly. This is useful for periodic duties like checking market prices, updating positions, or scanning for events. While there isn’t a cron-style scheduler UI yet, the interval is configurable in code, so developers can adjust frequency or implement more complex timing logic (like exponential backoff or specific times of day). **Conditional execution** is supported by letting the agent’s logic include if/then checks and external data queries. For example, an agent could each interval query a DEX price or an oracle, and only execute a trade if a certain threshold condition is met. Or it could monitor an on-chain event stream (using Sui’s event query API) and trigger when a specific event (like a large swap or a governance proposal) occurs. While not “one-click” in alpha, these conditional behaviors are achievable by coding them into the agent’s cycle. In essence, SAK provides the scaffolding to implement **both time-based and event-based triggers**. A concrete scenario: you could write an agent that wakes up every minute, checks a liquidity pool’s state, and _if_ a price disparity is detected, executes an arbitrage trade, then goes back to sleep. Such an agent would be continuously running and self-contained. _Looking forward:_ as the kit matures, we anticipate more out-of-the-box trigger primitives (perhaps a library of on-chain condition watchers, or integration with Sui’s subscription API for events), but even the alpha toolkit is enough to build robust scheduled tasks and conditional logic with a bit of coding.

- **Abstraction Layer for Move Contract Calls:** One of SAK’s biggest value-adds is simplifying how agents call Sui smart contracts. Under the hood, interacting with Sui’s Move contracts (publishing transactions, managing object IDs, etc.) can be complex, but SAK wraps common operations into easy-to-use functions. The kit basically acts as an **adapter over the Sui RPC/SDK**, exposing high-level methods for common actions. According to the documentation, SAK supports 15+ core Sui actions out-of-the-box. These include:

  - **Token operations:** checking wallet balances, transferring tokens/NFTs, even deploying new tokens.
  - **Staking operations:** staking SUI to validators, unstaking, and monitoring stake rewards.
  - **DeFi integrations:** interacting with Sui DeFi protocols like swapping on a DEX aggregator, lending/borrowing assets, etc..
  - **Sui Name Service (SuiNS):** registering a domain name or resolving an address.
  - **Others:** for example, creating a liquidity pool on Cetus (an AMM) is explicitly supported, and operations with specific protocols like **SuiLend** and **Springboard (SpringSui)** for staking are included.

  These abstractions mean a developer writing an agent does not have to manually craft Move calls or handle object IDs – they can call a function like `agent.swapTokens(A, B, amount)` or `agent.transferAsset(recipient, assetId)` and the kit handles the rest. This **shortens development time** and reduces errors, since the kit’s functions encapsulate best practices for those transactions. It’s effectively an _agent-oriented SDK for Sui_. Notably, many of these features rely on Mysten Labs’ Sui TypeScript SDK and dApp Kit under the hood; for example, NODO’s plan for AgentKit suggests using the `WalletAdapter` and `SuiClientProvider` from the Sui dApp Kit to handle wallet connections, and functions like `useTokenBalance` hook for fetching balances. This indicates SAK is built on top of Sui’s official libraries, adding a higher layer of AI/automation logic.

  The benefit to developers is huge: _you can invoke complex Move contracts with single function calls_. The kit also likely performs any necessary sequence of actions – e.g. for a swap, it might handle coin approvals, route selection (via aggregator), execution, and returning the result. As a developer, you work with familiar constructs instead of dealing with Move bytecode or transaction blocks. **Bottom line:** SAK’s abstraction layer translates agent intents into concrete Move calls safely and efficiently, letting developers focus on **what** the agent should do, not _how_ to do it on-chain.

- **Stateless vs. Stateful Agent Capabilities:** SAK supports both stateless and stateful agent designs, giving flexibility in how an agent maintains context. A **stateless agent** is one that treats each task independently – it doesn’t remember past interactions or accumulate data over time (except perhaps logs). Many simple bots are stateless: e.g. a price monitor agent that every hour checks a price and trades if needed doesn’t need memory of previous hours (apart from what’s on-chain). SAK can easily handle such cases: you could write an agent function that runs, performs a check/action, and ends, triggered anew each time by schedule or user prompt.

  However, many AI and multi-step use cases demand **statefulness** – the agent needs memory or persistent data across invocations. SAK alpha introduces statefulness primarily through **AI “memory” and on-chain/off-chain storage**. For example, in interactive Chat mode the agent can maintain conversational context (via LangChain memory) so it knows what was asked previously. In autonomous mode, an agent might keep track of what tasks it has already done or intermediate results. The kit’s LangChain integration explicitly mentions _Memory management for consistent interactions_ – meaning if an AI agent is, say, executing a 5-step plan, it can remember earlier steps and outcomes as it proceeds (this is in-memory state during runtime).

  For longer-term state, SAK can leverage Sui’s own storage solutions. Thanks to Sui’s object model and the new Walrus storage network, an agent can persist data on-chain or in decentralized storage. **Walrus integration** is particularly promising for stateful agents: Walrus is a decentralized storage layer on Sui designed for large data and accessible by smart contracts. An agent could use Walrus to store its knowledge base, logs, or even ML model parameters. In fact, Walrus is touted as ideal for autonomous agents to **share and consume data without leaks**. For example, one agent could drop a dataset or a computed result into Walrus, and another agent (or a later invocation of the same agent) can retrieve it as needed – enabling a form of shared memory. The Sui Foundation specifically notes Walrus allows agents to store historical data on-chain that they can later analyze. This blurs the line between stateless and stateful: an agent might not hold state in RAM indefinitely, but can write to Walrus or the chain and thus _externalize its state_ for future use (making it stateful in aggregate).

  Moreover, since Sui objects can serve as state, an agent could also use a Move smart contract as its “brain storage.” For example, an agent could have a Move object tracking how many times it executed, or storing last known market conditions – the agent updates this object each run and reads it on the next run. This pattern makes the agent _stateful across transactions in a trust-minimized way_. The current kit doesn’t automatically set this up, but the developer can code it using the provided transaction APIs.

  To summarize: SAK alpha allows stateless operation (simpler, easier to test) as well as stateful patterns using AI memory and Sui’s storage primitives. Many early agents might start stateless for simplicity, but the kit is ready for stateful needs – whether via in-process memory or durable storage like Walrus. As an illustration, consider a **portfolio management agent**: statelessly it could rebalance purely based on current prices each day (no memory of past decisions), while a stateful version might remember its last target allocation, store performance metrics, and adjust strategy over time. SAK gives developers the choice to implement either style. Notably, the combination of **zkLogin and state** is interesting – with zkLogin (discussed below) each agent or user could have an identity so that even if an agent restarts, it can recover its state associated with that identity from on-chain storage, effectively stateful across sessions.

- **AI Integration Features:** (This is somewhat beyond the explicit ask, but worth highlighting as a key feature set of SAK alpha.) The Sui Agent Kit is designed to integrate AI at its core. Some key AI-centric features include:

  - **LangChain Tools**: SAK provides ready-made LangChain tools that wrap Sui operations. This means if you’re using LangChain to build an LLM-driven agent, you can import a suite of Sui-specific tools (for balance check, token transfer, etc.) and the LLM can invoke those in its planning. Essentially, your AI agent “knows” how to perform blockchain actions via these tools.
  - **Autonomous Agent React Framework**: The kit supports an agent loop where an LLM can _react_ to observations and decide actions (similar to the ReAct pattern for LLMs). Pelagos’ kit mentions support for “autonomous agents with React framework” and a multi-agent architecture via LangGraph’s StateGraph. This implies sophisticated scenarios where multiple AI sub-agents (with specialized roles like a Planner, an Executor, a Reader, etc.) coordinate – which the kit can facilitate through a structured framework. This is a standout feature for advanced AI applications.
  - **Streaming Responses & Feedback**: The kit can stream AI outputs (useful if, say, the agent is having a conversation or providing updates). It can also incorporate feedback loops – e.g., if an action fails, the AI can get feedback and adjust its plan (enabled by that error handling/recovery feature).
  - **External Data Tools**: There are hints of agents being able to integrate price feeds or other external data as _AI tools_. For example, an agent might have a tool to fetch a price from an exchange API or to do NLP on social media sentiment, which can augment the agent’s decision-making.

  While not a separate bullet in the question, these AI features are a major selling point of SAK. They effectively turn Sui into a sandbox where AI-driven logic can not only _think_ (using LLMs) but also _act_ on-chain, and do so iteratively. This unlocks use cases like an agent that can understand natural language commands (“Invest \$100 in a low-risk strategy”), plan a series of on-chain steps (maybe split into yield farming, staking, etc.), execute them, and adjust over time – something unimaginable with basic scripting alone. Sui’s fast finality (transactions in <1 second) and high throughput complement this, as the agent can iterate quickly and even handle multiple actions in parallel if needed (Sui’s parallel execution means even multiple swaps or transfers can proceed without queuing if they touch independent objects).

In sum, the key features of Sui Agent Kit alpha revolve around making **automation and AI-on-blockchain easy**: scheduling, triggers, Move call abstraction, flexible state management, and first-class AI tool support. These features empower developers to create agents that are **proactive, intelligent, and deeply integrated** with Sui’s ecosystem, going well beyond simple scripts or cron jobs. Even in alpha, SAK is demonstrating how on-chain agents can handle everything from DeFi upkeep to security monitoring and user interactivity – all with minimal code and maximal leverage of Sui’s strengths.

## 4. Development and Operation Guidelines

Implementing and operating an agent with SAK alpha involves several steps and best practices. Here we outline a recommended developer workflow, gas and key management considerations, and how SAK can integrate with Sui’s identity/auth systems like zkLogin:

**Developer Workflow (from local dev to testnet/mainnet):**

1. **Setup and Local Development:** Start by installing the Sui Agent Kit (e.g. via `npm install`) and cloning any example repositories for reference. You’ll need Node.js (v18+ or 20+), and a Sui RPC endpoint. Often developers test against Sui’s **testnet or staging networks** first to avoid risking real assets. SAK allows specifying a custom RPC URL when initializing the agent – simply point this to a testnet full node (for example, `https://fullnode.testnet.sui.io:443`). Generate or use a testnet wallet key and fund it with test SUI for gas. In your `.env` or config, set the `SUI_PRIVATE_KEY` to this key and `RPC_URL` accordingly.
2. **Writing Agent Logic:** Implement your agent’s behavior in TypeScript or Python (depending on kit language – current kits are TS). Use the SAK APIs to define what the agent does each run. This could mean writing a loop that calls `await agent.someAction()` or setting up a LangChain agent that uses the provided Sui tools. It’s often helpful to begin with provided **examples** or modify them. For instance, Pelagos and Nimbus GitHub repos have example agents (like simple balance query or token swap bots) to use as templates. At this stage, you’ll focus on your agent’s core logic and unit test it in isolation if possible.
3. **Testing on Local Network or Testnet:** Before deploying broadly, test your agent. Sui provides a local network (sui-node) you can run, or you can use testnet. SAK includes automated tests – you can run `pnpm run test` which will execute a script (e.g. `test/index.ts`) to simulate agent actions. Ensure your `.env` is set for the environment you’re testing (for local network, use its RPC and a dev key; for testnet, use testnet RPC and key). Verify that the agent behaves as expected: does it trigger at the right times? Does it properly execute transactions (check Sui Explorer for the test transactions)? SAK’s docs recommend monitoring console logs during tests and ensuring you clean up any test artifacts (e.g., if your agent created temp objects or placed test orders).
4. **Iterate and Debug:** If something goes wrong (e.g., transaction failure), use Sui’s debugging tools and SAK’s error outputs to fix it. Common issues might be insufficient gas, incorrect object IDs, or logic errors. The kit’s abstraction usually prevents low-level mistakes, but you might still need to handle cases like _object version mismatch_ (if an object was used twice) or simply logical conditions not acting as intended. The good news is Sui’s fast finality means quick feedback during testing – you don’t wait long to see results and can iterate rapidly.
5. **Deployment to Mainnet:** Once satisfied on testnet, prepare for mainnet. Switch the RPC URL to a mainnet endpoint (e.g. `https://fullnode.mainnet.sui.io:443`) and set `SUI_PRIVATE_KEY` to a mainnet wallet key. **Important:** ensure this key is funded with enough SUI for gas fees. Mainnet gas costs are real, so estimate how much your agent might consume per day and load the wallet accordingly. Deploy the agent code to a reliable environment – possibly running on a cloud server or service for continuous operation. Many developers use a simple PM2 or Docker setup to keep the Node.js agent running. If using a launchpad or cloud function, follow their procedure (for SuiAI.fun, you might input your agent’s strategy into their interface; for a custom cloud VM, you’d start the script in a screen or as a service).
6. **Monitoring and Maintenance:** Once live on mainnet, monitor your agent’s performance. Track its transactions on Sui Explorer or via logging. SAK doesn’t (yet) provide a dedicated monitoring dashboard, so you might integrate with a logging service or simply output important info to console. Watch for failed transactions, catch exceptions, and consider edge cases (what if network latency spikes? what if the agent’s key runs low on SUI for gas?). Maintenance might involve updating the agent logic as protocols change (e.g., if a new version of a DEX comes out, update the API calls) or adding new features. Since SAK is alpha, also keep an eye on updates to the kit itself – new releases might fix bugs or add features you’ll want to incorporate.

**Gas Payment Handling and Relayers:** In the SAK alpha, **agents themselves are responsible for gas fees**. There is no built-in relayer or fee sponsorship mechanism provided. The agent’s configured private key is used to sign transactions and pay gas from its own SUI balance. This means as a developer you must ensure the agent’s wallet always has enough SUI to cover its transaction costs. For example, if your agent does frequent trades or complex transactions, load a buffer of SUI in the wallet. Gas costs on Sui are relatively low due to its efficient design, but they are not zero. Currently, the alpha kit does not integrate with any gas **relayer network** or Sui’s native sponsorship feature (Sui does have a concept of sponsored transactions, but that typically requires a third party to agree to pay for a specific transaction).

Given this, one best practice is to periodically check the wallet’s balance (SAK can easily do a balance check via its tools) and alert if low, or even auto-stake some SUI and auto-unstake when needed for gas (though that’s advanced). In a production scenario, a developer might top-up the agent’s gas or have a script to do so.

It’s worth noting that because SAK is oriented toward autonomous operation, a future enhancement could be integration with a relayer or meta-tx system so that, say, the agent’s actions could be paid by a dApp or user sponsoring them (this would be analogous to Gelato’s gasless transactions concept). But in alpha, **no such mechanism is present** – the agent’s wallet is the payer. There is also no fee market on Sui (gas price is fixed per protocol epoch), so you don’t worry about price spikes, but you do need enough balance.

Some developers have inquired about using **third-party relayers** (for instance, could you hook SAK with something like Biconomy or Gelato relays?). Out of the box, SAK doesn’t do this, but it’s possible to combine: e.g., an agent could submit transactions via a relayer service’s API, which then pays gas on its behalf. However, that introduces additional complexity and trust (and fees to the relayer). The simpler approach typically is to just use the agent’s own wallet.

**zkLogin and Authentication Options:** Sui’s **zkLogin** feature is a game-changer for identity and wallet management – it allows users (or potentially agents) to authenticate with familiar Web2 credentials (Google, Facebook, etc.) and obtain a Sui address that corresponds to that identity, using zero-knowledge proofs. The question is, how can this benefit SAK and autonomous agents?

In the ideal scenario, **each agent could have its own Sui wallet identity derived from zkLogin**. In fact, Sui’s vision includes giving each AI agent a wallet via zkLogin so it can easily transact without the friction of private key management. For example, an AI agent you deploy might be tied to your Google account login – meaning you (and only you) can authorize it to act, via standard login flows, rather than manually handling keys. This could greatly simplify deploying user-specific agents: a user could go to a launchpad, sign in with Google (zkLogin under the hood creates a Sui address), and an agent is spun up using that address for transactions. The user doesn’t manage keys at all; they just trust the zkLogin system to control the agent’s key linked to their login. Sui Foundation has explicitly noted that by giving each agent a crypto wallet through zkLogin, it removes the need for things like credit cards or off-chain payment rails – agents can _directly_ transact in digital currency securely.

In SAK alpha, direct zkLogin integration is not yet documented, but it’s likely on the roadmap. For now, developers typically use traditional keypairs. However, one could manually combine them: using Sui’s zkLogin SDK, you could obtain a proof and create a zkLogin-based address, then use that address’s associated key material in the agent. The complexity is that zkLogin addresses are controlled by an OIDC provider and a ZK proof process rather than a static private key – meaning an agent would need to be able to generate fresh proofs when sending transactions. This is non-trivial to do continuously (since zkLogin is meant for user-driven login sessions). More straightforward is using zkLogin as an onboarding tool: for example, an app can let a user log in with Google to set up an agent, then behind scenes either use that as a one-time key generation or link the agent’s standard key to the user’s identity.

Another authentication angle is **multi-sig or delegated keys**. In some frameworks (like MetaMask Snaps or delegation toolkit), you can delegate transaction rights. SAK doesn’t natively cover this in alpha, but one could conceive of an agent that holds a delegated capability – e.g., a user gives the agent’s address permission to move certain funds (like via a Move capability or adding as an authorized operator). This way, the agent doesn’t hold the user’s main key, but still can act on their assets. Implementation of such patterns will likely come as Sui matures its auth features (for instance, Capy capability system or KELP recovery could be leveraged).

In summary on auth: Today, you use a private key for the agent (stored securely in .env or a vault) and that’s it. But the horizon holds friendlier methods:

- **zkLogin**: so agents can be spun up with social logins, easing UX for non-devs.
- **OAUTH-like API keys**: perhaps giving agents scoped access to user wallets (not yet in SAK, but conceptually possible via Move).
- **MPC or Multi-sig**: sharing control of an agent among multiple parties or adding fail-safes (Autonolas leans into this, SAK not yet).

From an operational standpoint, if you deploy an agent for others, consider how they trust it. One might use zkLogin such that each user’s agent is tied to their login – they essentially control its key via their login, adding trust. Or use a factory contract on Sui to spawn a new agent object per user, with that object only able to do certain things (this would be a more on-chain agent approach).

**Relayers (if any):** As touched on, there’s currently no native relayer integration in SAK alpha. All transactions are direct. If a developer really wanted gas abstraction, they would need to integrate an external service on their own. For instance, you could code the agent to send a request to a relayer API (e.g. asking Gelato Relay or Biconomy to forward a transaction). That relayer would then pay gas and possibly charge your account elsewhere. But this is beyond the scope of SAK’s provided tools, and not something most alpha users do. It’s simpler to just load the agent’s wallet with SUI.

To conclude, **operating an SAK agent** involves careful key and gas management, iterative testing (especially on testnet), and potentially leveraging Sui’s unique features like zkLogin to simplify identity. Always keep security in mind: _never expose your private key_, and consider running agents in secure environments. Since the agents can hold assets or move funds, treat them like you would a hot wallet – use minimal necessary privileges and separate accounts for different agents or tasks. As SAK evolves, expect smoother integrations for auth and gas (the dream is an agent that you can deploy with one click, no key management, no manual gas – something launchpads are aiming for). But in alpha, a bit of devOps and key handling is part of the process.

## 5. Ecosystem Adoption and Use Cases

Even in its early stage, the Sui Agent Kit and the concept of on-chain agents on Sui have seen rapidly growing interest. A number of real-world (or at least _alpha-stage_) projects are already building with SAK or parallel agent frameworks, demonstrating diverse use cases. Here we highlight some notable examples and integration scenarios with Sui-native protocols:

- **DeFi Automation and Trading Bots:** A natural fit for SAK is automating DeFi tasks. Several teams in the Sui ecosystem are exploring this. For instance, **automated trading strategies on DeepBook** (Sui’s on-chain order book exchange) are a compelling use case. DeepBook provides CEX-like performance (\~390ms settlement) on-chain, which means an AI agent could place, cancel, or modify orders nearly in real-time. An agent could monitor DeepBook’s order books and execute an arbitrage or market-making strategy far faster than a human. Projects like _RaidenX_ have emerged as trading bot platforms for Sui, focusing on enabling users to trade meme coins or AI agent tokens via bots. While not explicitly stating they use SAK, the existence of such platforms validates the demand – and they likely use similar approaches (Sui SDK automation, etc.).

  A concrete example: imagine an agent that watches the price difference of a token between DeepBook and an AMM like Cetus. Using SAK, it could automatically execute arbitrage trades when a profitable spread arises – all autonomously. Another example is yield farming: an agent could move liquidity between pools to maximize yield, or auto-compound rewards. One project called **AlphaLend** was hinted (via Nimbus) to have position tracking and yield farming integrated with SAK – suggesting an agent that tracks lending positions and farms loot rewards. These financial use cases show how SAK can perform continuous portfolio management: _monitor liquidity pools, execute arbitrage, rebalance portfolios, stake/unstake assets_, etc. – exactly the tasks highlighted by the Sui Foundation as ideal for AI agents in DeFi. Users benefit by having 24/7 agents optimizing their assets.

- **Security Monitoring Agents:** Sui’s speed and transparency allow agents to be on-chain “sentinels.” A security agent could continuously scan transactions, contract events, or validator statuses to detect anomalies or attacks. This has been identified as a crucial application for AI agents. For instance, an agent might watch for large transfers to new contracts (which could indicate an exploit) or monitor for known malicious addresses interacting with a protocol. Upon detecting something, it could alert developers via X (Twitter) or even take on-chain action (e.g., trigger a circuit breaker contract). We’re seeing early stages of this: some Sui ecosystem projects are integrating monitoring – for example, an agent posting suspicious activity updates on social media. _Sui Shield_ (hypothetical name) could be an agent that live-tweets unusual contract calls. Because SAK can integrate with social platforms (through API calls or specific tools), an agent could serve as a bridge between on-chain data and off-chain notification. In fact, the Sui Foundation noted agents being used to provide _real-time updates through familiar channels like X and Telegram_. There are already agents on X (Twitter) that track blockchain events (for example, bots that tweet when large SUI moves or when specific NFTs are sold). SAK makes it straightforward to build such an agent: use SAK’s query functions to get events, and use an API call to tweet or message on Telegram.

- **Data Analysis and Oracles:** Another adoption area is agents that analyze on-chain data and provide insights (kind of like decentralized oracles or analytics bots). For example, an agent could crunch transaction history of a token to derive metrics (volatility, active addresses) and publish these periodically. Or an AI agent could combine on-chain data with off-chain (web scraping, news sentiment) to produce a “rating” or alert for a project. Because SAK can incorporate AI models, you could have an agent that reads all forum posts or tweets about a Sui project and flags potential governance issues. One concrete project is **OpenGraph**, mentioned earlier, which during the hackathon created an _on-chain AI inference system_ for agents. It lets you deploy ML models onto Sui and run them via agents, storing datasets on Walrus. This effectively means Sui can host oracles where the data processing (like running a TensorFlow model) is handled by an agent on-chain (using programmable transaction blocks to parallelize and reduce cost). Such an agent can then output results as a Sui object that other contracts trust as an oracle feed. SAK can tie into this by orchestrating when to run the model, verifying outputs, etc. The hackathon (called **Sui Agent Typhoon**) itself indicates lots of teams are embracing SAK-like ideas – OpenGraph was one winner, but others tackled things like gaming agents, DeSci agents, etc., using Walrus and SAK.

- **Integration with Walrus (Decentralized Storage):** Walrus, Sui’s storage network, is quickly becoming part of agent-based projects. **Pelagos AI’s deployment of Sui Agent Kit on Walrus** is a prime example: they hosted their toolkit’s web content on Walrus to showcase trustless deployment. More interestingly, Walrus enables agents to handle large data that wouldn’t fit in regular on-chain storage. A use case might be an **AI NFT agent** – an agent that generates art or music. The agent could create an image (using an AI model) and then store the result on Walrus, and mint an NFT pointing to it. This ensures the artwork persists decentralized. SAK would handle the on-chain steps (minting, transactions) while the AI part generates content and Walrus stores it. Another scenario is collaborative data analysis: multiple agents could write to a common Walrus dataset (say a big CSV of processed data), collectively building a knowledge base. Because Walrus is optimized for large files and offers on-chain availability proofs, agents can rely on it for anything from model weights (imagine deploying a fine-tuned GPT model’s parameters via Walrus so any agent can load it) to logs. In the **Talus partnership** announcement, Mysten Labs explicitly pointed out that Walrus can hold large AI models off-chain and provide _trusted on-chain historical data_ for AI agents. “Trusted” is key: an agent can trust data from Walrus because of cryptographic proofs, which is better than scraping random APIs. Already, Walrus is branded as built for autonomous agents’ needs. We expect SAK-based projects to increasingly use Walrus as the data layer – whether it’s a strategy data file for a trading bot, a cache of user preferences for a personalized agent, or sharing info between agents in a DAO.

- **Sui Native Protocol Integrations:** The kit’s creators have integrated numerous Sui protocols, signaling early **ecosystem adoption** through those integrations. For example, support for **Cetus DEX** and **Turbos Finance** means agents can trade on those platforms easily. A project might create an arbitrage agent that swaps on Cetus when prices differ from DeepBook. **SuiLend** integration allows building agents that manage loans – e.g., an agent that automatically adjusts a borrowing position to avoid liquidation (by repaying or adding collateral if health factor drops). **Navi** (an aggregator) integration lets an agent always get the best swap rate across platforms, which a yield-farming agent would use. We also see **Spring Sui (Springboard)** integration for staking operations – an agent could ensure a user’s SUI is always staked when idle and unstake when needed for a purchase, automating yield on base assets.

  Additionally, mention should be made of **DeepBook** itself launching its own token (DEEP) and possibly governance – agents could be participants in governance (voting automatically according to a user’s strategy). SAK could enable an agent to monitor governance proposals on-chain and vote on behalf of a user per predefined rules or even AI judgement. This moves into the realm of **DAOs and AI governors**, which is nascent but on the radar (Autonolas, for instance, had a “Governatooorr” AI delegate for governance voting). With Sui’s focus on mainstream adoption, having AI agents handle some governance or community tasks could boost participation.

- **AI Agent Launchpads and Social Applications:** The rise of platforms like SuiAI.fun (which even issued a token, SUIAI) shows community interest in packaging agents for general users. On SuiAI.fun, people can create or invest in agent tokens – e.g., a “Dolphin Agent” that provides market insights. While some of these may be meme-like, the concept is that non-developers can benefit from agents by simply selecting one from a marketplace. SAK is likely powering or inspiring these under the hood. Another example is **Agents for content creation**: The Sui Foundation blog mentions agents even in meme creation or content generation contexts. For instance, an agent might generate and post memes or NFT storylines based on community trends – a playful but popular use (there was reference to an “Agents.fun” in Olas context for content agents). On Sui, such an agent could live-post to social media and mint meme NFTs if desired.

- **Cross-chain Control and IKA:** One intriguing early adopter is **Ika** – a project focusing on secure multi-party control (MPC) and cross-chain operations. Ika’s protocol allows Sui smart contracts to control assets on other chains. This means an agent on Sui could effectively reach out to other blockchains via Ika. If combined with SAK, you could have an agent that not only does Sui tasks but also triggers cross-chain moves (like moving liquidity from Ethereum to Sui when needed). While Ika’s integration is more about Sui contracts, an agent could call an Ika-enabled Move contract to achieve cross-chain effects. The Sui Foundation invested in Ika, showing their interest in agents that operate multi-chain. We might soon see an **agent that rebalances between Sui and Ethereum DeFi** by using Ika under the hood – for example, sensing higher yield on Uniswap on Ethereum and moving funds via Ika to Sui and vice versa. This broadens the agent use cases beyond just Sui ecosystem to an inter-chain world, with Sui as the command center.

In summary, the ecosystem is already **experimenting with SAK and AI agents** in numerous domains:

- **DeFi bots** (trading, arbitrage, yield optimization) – leveraging DeepBook, Cetus, SuiLend, etc., often aiming for 24/7 portfolio management.
- **Security and infrastructure agents** – monitoring networks, managing data (like DePIN agents that optimize physical network resources).
- **Data and social agents** – curating information, interfacing with users via X/Telegram, producing content or insights (making Web3 data accessible in real-time).
- **Specialized vertical agents** – e.g., DeSci agents that automate scientific funding or research NFTs, or DePIN agents for IoT networks, as highlighted in Sui Foundation’s blog.

It’s worth noting many of these are in **alpha or hackathon stage** themselves. But they indicate strong adoption: less than a year into Sui’s mainnet, developers have embraced the agent paradigm. The Sui Basecamp 2025 event underscored this, with numerous talks on AI agents and partnerships (e.g., Talus’s Nexus framework partnering with Sui, as we saw). The synergy of SAK with protocols like DeepBook and Walrus demonstrates that Sui is assembling a full-stack: _computing (AI/agents), storage (Walrus), liquidity (DeepBook), identity (zkLogin), and more_, all working in concert.

For a developer, these use cases and early projects provide inspiration and patterns to follow. If building with SAK, you can look at Pelagos’s open-source agent kit repo, Nimbus’s toolkit and examples, or hackathon winners like OpenGraph for guidance. The community is active: there’s already an **“Awesome Sui” list that includes Sui Agent Kit** resources and Nimbus data services. As SAK matures from alpha to beta and beyond, we can expect more polished case studies and perhaps out-of-the-box agents for common needs.

**Key takeaway:** Sui’s ecosystem is rapidly embracing autonomous agents, and the Sui Agent Kit (alpha) is at the heart of this movement. Whether it’s optimizing DeFi strategies, powering AI-driven dApps, or coordinating cross-chain operations, SAK-based agents are proving effective. By leveraging Sui’s unique tech – DeepBook’s speed, Walrus’s storage, zkLogin’s seamless auth – these agents can do things that would be difficult on other chains. Developers looking to adopt SAK should study these early use cases as they offer **actionable insight** into what works and how to implement it. From a simple scheduled token swap bot to a complex multi-agent AI DAO, SAK alpha provides the building blocks to get started today, with the confidence that many in the community are on the same journey of innovation.

**Sources:**

- Sui Agent Kit repositories and docs (Nimbus & Pelagos)
- Sui Foundation & Mysten Labs announcements
- Sui Foundation blog: _“All About AI Agents”_ (Mar 2025)
- Chainflow recap of AI Agents panel (on agent adoption and toolkits)
- Coinbase Dev Blog on AgentKit (context of bridging AI and on-chain)
- Autonolas (Olas) documentation for comparison
- Gelato Network overview for comparison
- BlockchainGamer article on Sui x Talus (AI agents & Walrus)
- Gate.io Learn article quoting Sui roadmap for agents and zkLogin
- Sui Basecamp 2025 Fullstack blog (mentions DeepBook, Walrus integration).
